\chapter{Anexos} 

\section{Código del sitema}
\label{app:code}

\subsection{Código principal}
\label{code:code_main}
    
    \begin{minted}[frame=lines, framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,linenos]{python}
    from __future__ import division, absolute_import                 
    # to avoid integer devision problem
    import datetime 
    import scipy
    import pylab
    #
    import random
    import math
    #
    import datetime
    import time
    from yaspin.yaspin import yaspin
    import os
    import json
    import sys
    import subprocess
    import itertools
    import operator
    import shutil
    import numpy as np
    from copy import deepcopy

    # Local files
    import XmlHelpers as xml
    import Evaluation as Eval 
    from Selection import Selection
    from Mutation import Mutation

    author = "Salinas Hernandez Jaime"
    copyright = "Copyright 2018, Tijuana Institute of Technology"
    credits = ["Dr. Mario García Valdez",""]
    license = "ITT"
    version = "1.4.1"
    date = "May 08, 2019 18:30"
    maintainer = "Salinas Hernandez Jaime"
    email = "jaime.salinas@tectijuana.edu.mx"
    status = "Development"
    t_begin = datetime.datetime.now()
    t_prev = datetime.datetime.now()


    ## Values used for the genetic algorithm
    population = 10         # For now it can only be below 10
    max_gen = 100            # Max number of generations
    fits = [0]              # Variable to save the fitness of each generation
    gen = 0                 # Generation 1
    per_cross = 0.5         # Percentage of cross-over (cross-over operator)
    per_comb = 0.3          # Percentage of combination (combination operator)
    per_mut = 0.8           # Percentage of mutation
    sel_type = 1            # Selection (for crossover) type [ 0: Random - 1: Tournament - TBD]
    cross_type = 0          # Type of cross-over [ 0: One point CO - 1: Random point CO - TBD]
    ind_pieces = 20         # Number of pieces that define an individual
    all_fit = [0]            # Average fitness for all generations
    fit_ham = []           # Average piece length fitness for all generations
    fit_Amov = []           # Average movement fitness for all generations
    max_elite = 1           # Maximum number of elite members in the generation
    elite = []
    best_gen = []
    mu = 0                  # Mean for normal distribution
    sigma = 20              # SD for normal distribution

    min_fit = [0]            # Average fitness for all generations
    max_fit = [0]            # Average fitness for all generations

    ## Data required to create the xml files

    #####################################################################
    ##############< Data required to create the xml files >##############
    #####################################################################

    project_root = os.getcwd()
    json_data = {}
    json_data['all_fit'] = []
    json_data['hamming_avg'] = []
    json_data['min_fit'] = []
    json_data['max_fit'] = []
    ruleset = open("Ruleset/parameters.txt", "r")
    config_param = json.loads(open("ga_parameters.json","r").read())

    game_path = config_param['game_path']
    write_path = config_param['write_path']
    elite_path = config_param['elite_path']
    read_path = config_param['read_path']
    log_path = config_param['log_dir']
    log_base_name = config_param['log_base_name']
    child_level = config_param['child_level']
    child_output = config_param['child_output']

    # For tournament
    game_path_tourney = config_param['game_path_tourney']
    write_path_tourney = config_param['write_path_tourney']
    read_path_tourney = config_param['read_path_tourney']

    # To have a copy of the generations
    level_files_path = config_param['level_files']
    current_gen_folder = config_param['generation']
    sourcefolder = os.path.join(project_root, level_files_path + "/Levels")
    experimentsource = os.path.join(project_root, level_files_path)
    foldername = ''.join(e for e in str(datetime.datetime.now()) if e.isalnum())
    experimentdest = config_param['experiment_results'] + "/" + foldername
    experimentdestination = os.path.join(project_root, experimentdest)

    # Data for the competition
    req_levels = int(deepcopy(ruleset.readline()))
    req_np_combinations = ruleset.readline().split(',')
    for i, e in enumerate(req_np_combinations):
        req_np_combinations[i] = req_np_combinations[i].split()
    req_pigs = ruleset.readline().split(',')

    max_elite = req_levels

    # Clean previous experiment
    #shutil.rmtree(os.path.join(project_root, write_path))
    #shutil.rmtree(os.path.join(project_root, elite_path))
    shutil.rmtree(os.path.join(project_root, level_files_path))

    os.makedirs(os.path.join(project_root, level_files_path), exist_ok=True)

    os.makedirs(os.path.join(project_root, write_path), exist_ok=True)
    os.makedirs(os.path.join(project_root, elite_path), exist_ok=True)
    os.makedirs(os.path.join(project_root, read_path), exist_ok=True)

    os.makedirs(os.path.join(project_root, log_path), exist_ok=True)



    ## "Dictionary" to save the base pieces and structures
    SW_HIDE = 0
    info = subprocess.STARTUPINFO()
    info.dwFlags = subprocess.STARTF_USESHOWWINDOW
    info.wShowWindow = SW_HIDE

    #just for fun making further development easier and with joy
    pi     = scipy.pi
    dot    = scipy.dot
    sin    = scipy.sin
    cos    = scipy.cos
    ar     = scipy.array
    rand   = scipy.rand
    arange = scipy.arange
    plot   = pylab.plot
    show   = pylab.show
    axis   = pylab.axis
    grid   = pylab.grid
    title  = pylab.title
    rad    = lambda ang: ang*pi/180                 #lovely lambda: degree to radian



    # Function to rotate points
    def Rotate2D(pts,cnt,ang=pi/4):
        '''pts = {} Rotates points(nx2) about center cnt(2) by angle ang(1) in radian'''
        return dot(pts-cnt,ar([[cos(ang),sin(ang)],[-sin(ang),cos(ang)]]))+cnt


    # Generation masks
    type_small_l = [[0,0,0,0,0,0,0],
                    [0,0,2,0,0,0,0],
                    [0,0,1,1,0,0,0]]
    type_large_l = [[0,0,3,0,0,0,0],
                    [0,0,2,0,0,0,0],
                    [0,0,1,1,0,0,0]]
    type_small_cube = [[0,0,0,0,0,0,0],
                        [0,0,2,2,0,0,0],
                        [0,0,1,1,0,0,0]]
    type_large_cube = [[0,3,3,3,0,0,0],
                        [0,2,2,2,0,0,0],
                        [0,1,1,1,0,0,0]]
    type_small_floor = [[0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0],
                        [0,1,1,1,1,1,0]]
    type_large_floor = [[0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0],
                        [1,1,1,1,1,1,1]]
    type_castle = [[0,0,0,3,0,0,0],
                    [2,0,2,2,2,0,2],
                    [1,1,1,1,1,1,1]]
    type_house = [[0,0,3,3,0,0,0],
                    [0,2,2,2,2,0,0],
                    [0,1,1,1,1,0,0]]
    type_towers = [[3,0,3,0,3,0,0],
                    [2,0,2,0,2,0,0],
                    [1,0,1,0,1,0,0]]

    Mask_List = [
        type_small_l,
        type_large_l,
        type_small_cube,
        type_large_cube,
        type_small_floor,
        type_large_floor,
        type_castle,
        type_house,
        type_towers
    ]

    # Global Piece class and a class for each piece in the game
    class Piece:
        def __init__(self, x, y, r, mat):
            #self.Height = 72
            #self.Width = 72
            self.Material = mat
            self.Dict = []
            self.Valid = True
            self.X = x
            self.Y = y
            self.R = r
            if self.Materials[0] == 0:
                self.Material = "stone"
            if self.Materials[1] == 0:
                self.Material = "ice"
            
        
        def get_edges(self):
            ed_lis = []
            ed_lis.append([self.Width/2 +     self.X,      self.Height/2 +  self.Y])
            ed_lis.append([self.Width/2 +     self.X, 0 -  self.Height/2 +  self.Y])
            ed_lis.append([0 - self.Width/2 + self.X, 0 -  self.Height/2 +  self.Y])
            ed_lis.append([0 - self.Width/2 + self.X,      self.Height/2 +  self.Y])
            self.Edges = ed_lis

        def get_points(self, r):
            ang = self.R * pi / 180
            ots = Rotate2D(self.Edges, ar([0 + self.X, 0 + self.Y]), ang)
            self.Points = ots.tolist()
            #print(self.Points)

        def change_material(self, m):
            self.Material = m

        def as_dictionary(self):
            self_list = []
            self_list.append(self.Name)
            self_list.append(self.Material)
            self_list.append(self.X)
            self_list.append(self.Y)
            self_list.append(self.R)
            self.Dict = self_list
            
        def update_values(self):
            #if 'errormessage' in kwargs:
            #    print("llegue")
            #else: 
            #    self.Material = kwargs.get('material')
            #self.Material = "ice"
            self.get_edges()
            self.get_points(self.R)
            self.as_dictionary()

    class Circle(Piece):
        def __init__(self, mat, x=0, y=0, r=0):
            self.Name = "Circle"
            self.Height = 75
            self.Width = 75
            Piece.__init__(self, x, y, r, mat)
            self.update_values()

    class RectTiny(Piece):
        def __init__(self, mat, x=0, y=0, r=0):
            self.Name = "RectTiny"
            self.Height = 25
            self.Width = 45
            Piece.__init__(self, x, y, r, mat)
            self.update_values()
        

    class RectSmall(Piece):
        def __init__(self, mat, x=0, y=0, r=0):
            self.Name = "RectSmall"
            self.Height = 25
            self.Width = 85
            Piece.__init__(self, x, y, r, mat)
            self.update_values()


    class RectMedium(Piece):
        def __init__(self, mat, x=0, y=0, r=0):
            self.Name = "RectMedium"
            self.Height = 25
            self.Width = 165
            Piece.__init__(self, x, y, r, mat)
            self.update_values()


    class RectBig(Piece):
        def __init__(self, mat, x=0, y=0, r=0):
            self.Name = "RectBig"
            self.Height = 25
            self.Width = 185
            Piece.__init__(self, x, y, r, mat)
            self.update_values()


    class RectFat(Piece):
        def __init__(self, mat, x=0, y=0, r=0):
            self.Name = "RectFat"
            self.Height = 45
            self.Width = 85
            Piece.__init__(self, x, y, r, mat)
            self.update_values()


    class SquareTiny(Piece):
        def __init__(self, mat, x=0, y=0, r=0):
            self.Name = "SquareTiny"
            self.Height = 22
            self.Width = 22
            Piece.__init__(self, x, y, r, mat)
            self.update_values()


    class SquareSmall(Piece):
        def __init__(self, mat, x=0, y=0, r=0):
            self.Name = "SquareSmall"
            self.Height = 45
            self.Width = 45
            Piece.__init__(self, x, y, r, mat)
            self.update_values()


    class Triangle(Piece):
        def __init__(self, mat, x=0, y=0, r=0):
            self.Name = "Triangle"
            self.Height = 75
            self.Width = 75
            Piece.__init__(self, x, y, r, mat)
            self.update_values()


    class TriangleHole(Piece):
        def __init__(self, mat, x=0, y=0, r=0):
            self.Name = "TriangleHole"
            self.Height = 85
            self.Width = 85
            Piece.__init__(self, x, y, r, mat)
            self.update_values()


    class SquareHole(Piece):
        def __init__(self, mat, x=0, y=0, r=0):
            self.Name = "SquareHole"
            self.Height = 85
            self.Width = 85
            Piece.__init__(self, x, y, r, mat)
            self.update_values()


    # Composite class to control the generation of the individuals
    class Composite:
        
        bl_list_x = []
        bl_list_y = []
        
        def __init__(self, blocks):
            # Blocks must be a list
            self.Objetos2 = []
            self.bl_list_x = []
            self.bl_list_y = []
            self.blocks = blocks.copy()
            self.Objetos = [clases[clase](m,x,y,r) for (clase,x,y,r,m) in 
                self.blocks.copy()]
            self.get_values()
            self.height = self.height()
            self.width = self.width()
            self.top_center = self.gen_top_center()
            self.as_dictionary = self.gen_dictionary()
            self.low_center = self.get_low_center()
            self.overtop_center = self.get_overtop()
            
        def get_values(self):
            if len(self.blocks) > 2:
                self.Pig = True
            else:
                self.Pig = False
            self.Borders = [[(x,y) for (x,y) in Obj.Points] for Obj in self.Objetos]
            self.Borders = sum(self.Borders, [])
            self.Width = abs(min(self.Borders, key=lambda t:t[0])[0] - max(self.Borders, 
                key=lambda t:t[0])[0])
            self.Height = abs(min(self.Borders, key=lambda t:t[1])[1] - max(self.Borders, 
                key=lambda t:t[1])[1])
            return 0

        def height(self):
            return 0.0

        def width(self):
            return 0.0
        
        def set_borders(self):
            
            return 0.0

        def gen_top_center(self):
            height_center = self.Height/2
            lenght_center = 0
            return [lenght_center, height_center]
        
        def get_low_center(self):
            return [0, self.Height/2]
        
        def get_overtop(self):
            return [0, self.Height]

        def gen_dictionary(self):
            block_list = []
            block_list.append([self.Width, self.Height]) 
            # Width represents the x coordinate and Height the y one
            for piece in self.Objetos:
                block_comp = []
                block_comp.append(piece.Dict[0])
                block_comp.append(piece.Dict[1])
                block_comp.append(piece.Dict[2])
                block_comp.append(piece.Dict[3])
                block_comp.append(piece.Dict[4])
                block_list.append(block_comp)
            #block_list.append(block_comp)
            #print(block_list)
            return block_list
        
        def move_xy(self, n_x, n_y, mat_f, el_r):
            #self.X = n_x
            #self.Y = n_y
            self.Objetos = [clases[clase](mat_f, x + n_x, y + n_y, el_r) for 
                (clase,x,y,r, mat) in self.blocks.copy()]
            return 0
        
        def as_json(self):
            return {}
        

    clases = {
            "Circle":Circle,
            "RectTiny":RectTiny,
            "RectSmall":RectSmall,
            "RectMedium":RectMedium,
            "RectBig":RectBig,
            "RectFat":RectFat,
            "SquareTiny":SquareTiny,
            "SquareSmall":SquareSmall,
            "SquareHole":SquareHole,
            "Triangle":Triangle,
            "TriangleHole":TriangleHole }

    clases1 = {
            "Circle":Circle
            }

    Composites = {
        0: [("RectTiny", 0, 0, 0, "wood")],
        1: [("RectSmall", 0, 0, 0, "wood")],
        2: [("RectMedium", 0, 0, 0, "wood")],
        3: [("RectBig", 0, 0, 0, "wood")],
        4: [("RectFat", 0, 0, 0, "wood")],
        5: [("SquareSmall", 0, 0, 0, "wood")],
        6: [("SquareHole", 0, 0, 0, "wood")],
        7: [("Circle", 0, 0, 0, "wood")],
        8: [("TriangleHole", 0, 0, 0, "wood")]
    }

    Composites_res = {
        0: [("RectTiny", 0, 0, 0, "wood", True)],
        1: [("RectSmall", 0, 0, 0, "wood", True)],
        2: [("RectMedium", 0, 0, 0, "wood", True)],
        3: [("RectBig", 0, 0, 0, "wood", True)],
        4: [("RectFat", 0, 0, 0, "wood", True)],
        5: [("SquareSmall", 0, 0, 0, "wood", True)],
        6: [("SquareHole", 0, 0, 0, "wood", True)],
        7: [("Circle", 0, 0, 0, "wood", True)],
        8: [("TriangleHole", 0, 0, 0, "wood", True)]
    }

    materials = {
            "wood": 0,
            "stone": 1,
            "ice": 2}

    restrictions = {
            "Circle": [1,1,1],
            "CircleSmall": [1,1,1],
            "RectTiny": [1,1,1],
            "RectSmall": [1,1,1],
            "RectMedium": [1,1,1],
            "RectBig": [1,1,1],
            "RectFat": [1,1,1],
            "SquareTiny": [1,1,1],
            "SquareSmall": [1,1,1],
            "SquareHole": [1,1,1],
            "Triangle": [1,1,1],
            "TriangleHole": [1,1,1] }

    for element in req_np_combinations:
        restrictions[element[1]][materials[element[0]]] = 0
        
    for piece in Composites_res:
        clases[Composites_res[piece][0][0]].Materials = restrictions[Composites_res[piece][0][0]]
        
    for piece in Composites_res:
        if sum(clases[Composites_res[piece][0][0]].Materials) == 0:
            clases[Composites_res[piece][0][0]].Valid = False
        else:
            clases[Composites_res[piece][0][0]].Valid = True
            #if clases[Composites_res[piece][0][0]].Materials[0] == 0:
                
        #if sum(piece.Materials) == 0:
            #piece.Valid = False
    def get_random_chrom(sl):
        asl = 0
        chrom = []
        while asl < sl:
            prop = random.randint(0, len(Composites)-1)
            if clases[Composites[prop][0][0]].Valid == True:
                chrom.append(prop)
                asl += 1
        #random.randint(0,len(Composites)-1) for p in range(ind_pieces)
        return chrom

    def combine_pieces():
        piece1 = random.randint(0, len(Composites)-1)
        piece2 = random.randint(0, len(Composites)-1)
        new_value = len(Composites)
        prop1 = Composite(Composites[piece1])
        prop2 = Composite(Composites[piece2])
        final_group = []
        if piece1 == piece2:
            initial = random.randint(0,1)
            
            if initial == 0: # Estaran pegados
                # Checar si los bordes coinciden
                #print("Igual pegados")
                prop1.move_xy(prop1.Width/2,0,prop1.Objetos[0].Material, 0)
                prop2.move_xy((0-(prop2.Width/2)),0,prop2.Objetos[0].Material, 0)
                prop1.get_values()
                prop2.get_values()
                list1 = prop1.Borders
                list2 = prop2.Borders
                # Calculate center point of each piece and add to list
                test=Composites[piece1].copy()
                for comp in test:
                    temp = []
                    temp.append(comp[0])
                    temp.append(int(comp[1]) + (prop1.Width/2))
                    temp.append(int(comp[2]))
                    temp.append(int(comp[3]))
                    temp.append(comp[4])
                    fin = tuple(temp)
                    final_group.append(fin)
                test = Composites[piece2].copy()
                for comp in test:
                    temp = []
                    temp.append(comp[0])
                    temp.append(int(comp[1]) - (prop2.Width/2))
                    temp.append(int(comp[2]))
                    temp.append(int(comp[3]))
                    temp.append(comp[4])
                    fin = tuple(temp)
                    final_group.append(fin)
            else:
                mov_rand = random.randint(math.ceil(prop1.Width/2),90)
                #print("Igual separados")
                prop1.move_xy((prop1.Width/2) + mov_rand,0,prop1.Objetos[0].Material, 0)
                prop2.move_xy((0-((prop2.Width/2) + mov_rand)),0,prop2.Objetos[0].Material, 0)

                prop1.get_values()
                prop2.get_values()
                prop3 = Composite(Composites[3])
                
                prop3.move_xy(0,(prop1.Height/2)+(prop3.Height/2), prop3.Objetos[0].Material, 0)
                prop3.get_values()

                points = [[(prop1.Width/2) + mov_rand,0], [(0-((prop2.Width/2) + mov_rand)),0], 
                    [0,(prop1.Height/2)+(prop3.Height/2)]]
                com = np.mean(points, axis=0)
                delta = np.array((0,0)) - com
                shifted_points = points + delta

                list1 = prop1.Borders
                list2 = prop2.Borders
                list3 = prop3.Borders
                #final_group.extend(Composites[piece1])
                #final_group.extend(Composites[piece2])
                #final_group.extend(Composites[3])
                #print(list3)
                test=Composites[3].copy()
                for comp in test:
                    temp = []
                    temp.append(comp[0])
                    #temp.append(int(comp[1]))
                    #temp.append(int(comp[2]) + (prop1.Height/2)+(prop3.Height/2) + 1)
                    temp.append(shifted_points[2][0])
                    temp.append(shifted_points[2][1]+1)
                    temp.append(int(comp[3]))
                    temp.append(comp[4])
                    fin = tuple(temp)
                    final_group.append(fin)
                test = Composites[piece1].copy()
                for comp in test:
                    temp = []
                    temp.append(comp[0])
                    #temp.append(int(comp[1]) + (prop1.Width/2) + mov_rand + 1)
                    #temp.append(int(comp[2]))
                    temp.append(shifted_points[0][0])
                    temp.append(shifted_points[0][1])
                    temp.append(int(comp[3]))
                    temp.append(comp[4])
                    fin = tuple(temp)
                    final_group.append(fin)
                test = Composites[piece2].copy()
                for comp in test:
                    temp = []
                    temp.append(comp[0])
                    #temp.append(int(comp[1]) + (0-((prop2.Width/2) + mov_rand)) - 1)
                    #temp.append(int(comp[2]))
                    temp.append(shifted_points[1][0])
                    temp.append(shifted_points[1][1])
                    temp.append(int(comp[3]))
                    temp.append(comp[4])
                    fin = tuple(temp)
                    final_group.append(fin)
            Composites.update({new_value:final_group})
        else:
            #print("Diferente pegados")
            ap1 = prop1.Width*prop1.Height
            ap2 = prop2.Width*prop2.Height
            if ap1 > ap2:
                if prop1.Width >= 90:
                    #print("Vertical")
                    prop1.Objetos[0].R = 90
                    prop1.Objetos[0].update_values()
                    prop1.move_xy(0,(0-(prop1.Width/2)),prop1.Objetos[0].Material, 90)

                    prop2.move_xy(0,(prop2.Height/2),prop2.Objetos[0].Material, 0)

                    points = [[0,(0-(prop1.Width/2))], [0,(prop2.Height/2)]]
                    com = np.mean(points, axis=0)
                    delta = np.array((0,0)) - com
                    shifted_points = points + delta
                    test = Composites[piece1].copy()
                    for comp in test:
                        temp = []
                        temp.append(comp[0])
                        #temp.append(int(comp[2]) + (prop1.Width/2))
                        temp.append(shifted_points[0][0])
                        temp.append(shifted_points[0][1]-1)
                        temp.append(90)
                        temp.append(comp[4])
                        fin = tuple(temp)
                        final_group.append(fin)
                    test = Composites[piece1].copy()
                    for comp in test:
                        temp = []
                        temp.append(comp[0])
                        #temp.append(int(comp[1]) + (0-((prop2.Width/2))) - 1)
                        temp.append(shifted_points[1][0])
                        temp.append(shifted_points[1][1]+1)
                        #temp.append(int(comp[2]))
                        temp.append(int(comp[3]))
                        temp.append(comp[4])
                        fin = tuple(temp)
                        final_group.append(fin)
                else:
                    #print("Horizontal")
                    prop1.move_xy((0-(prop1.Width/2)),0,prop1.Objetos[0].Material, 0)
                    prop2.move_xy((prop2.Width/2),0,prop2.Objetos[0].Material, 0)
                    points = [[0,(0-(prop1.Width/2))], [0,(prop2.Width/2)]]
                    com = np.mean(points, axis=0)
                    delta = np.array((0,0)) - com
                    shifted_points = points + delta
                    test = Composites[piece1].copy()
                    for comp in test:
                        temp = []
                        temp.append(comp[0])
                        #temp.append(int(comp[1]))
                        #temp.append(int(comp[2]) + (prop1.Width/2))
                        temp.append(shifted_points[0][0])
                        temp.append(shifted_points[0][1])
                        temp.append(int(comp[3]))
                        temp.append(comp[4])
                        fin = tuple(temp)
                        final_group.append(fin)
                    test = Composites[piece2].copy()
                    for comp in test:
                        temp = []
                        temp.append(comp[0])
                        #temp.append(int(comp[1]) + (0-((prop2.Width/2))) - 1)
                        temp.append(shifted_points[1][0])
                        temp.append(shifted_points[1][1])
                        #temp.append(int(comp[2]))
                        temp.append(int(comp[3]))
                        temp.append(comp[4])
                        fin = tuple(temp)
                        final_group.append(fin)
            else:
                if prop2.Width >= 90:
                    #print("Vertical")
                    prop2.Objetos[0].R = 90
                    prop2.Objetos[0].update_values()
                    prop2.move_xy(0,(0-(prop2.Width/2)),prop2.Objetos[0].Material, 90)
                    prop1.move_xy(0,(prop1.Height/2),prop1.Objetos[0].Material, 0)
                    points = [[0,(0-(prop2.Width/2))], [0,(prop1.Height/2)]]
                    com = np.mean(points, axis=0)
                    delta = np.array((0,0)) - com
                    shifted_points = points + delta
                    test = Composites[piece1].copy()
                    for comp in test:
                        temp = []
                        temp.append(comp[0])
                        #temp.append(int(comp[1]))
                        #temp.append(int(comp[2]) + (prop1.Width/2))
                        temp.append(shifted_points[0][0])
                        temp.append(shifted_points[0][1]+1)
                        temp.append(int(comp[3]))
                        temp.append(comp[4])
                        fin = tuple(temp)
                        final_group.append(fin)
                    test = Composites[piece2].copy()
                    for comp in test:
                        temp = []
                        temp.append(comp[0])
                        #temp.append(int(comp[1]) + (0-((prop2.Width/2))) - 1)
                        temp.append(shifted_points[1][0])
                        temp.append(shifted_points[1][1]-1)
                        #temp.append(int(comp[2]))
                        temp.append(90)
                        temp.append(comp[4])
                        fin = tuple(temp)
                        final_group.append(fin)
                else:
                    #print("Horizontal")
                    prop2.move_xy((0-(prop2.Width/2)),0,prop2.Objetos[0].Material, 0)
                    prop1.move_xy((prop1.Width/2),0,prop1.Objetos[0].Material, 0)
                    points = [[0,(0-(prop2.Width/2))], [0,(prop1.Width/2)]]
                    com = np.mean(points, axis=0)
                    delta = np.array((0,0)) - com
                    shifted_points = points + delta
                    test = Composites[piece1].copy()
                    for comp in test:
                        temp = []
                        temp.append(comp[0])
                        #temp.append(int(comp[1]))
                        #temp.append(int(comp[2]) + (prop1.Width/2))
                        temp.append(shifted_points[0][0])
                        temp.append(shifted_points[0][1])
                        temp.append(int(comp[3]))
                        temp.append(comp[4])
                        fin = tuple(temp)
                        final_group.append(fin)
                    test = Composites[piece2].copy()
                    for comp in test:
                        temp = []
                        temp.append(comp[0])
                        #temp.append(int(comp[1]) + (0-((prop2.Width/2))) - 1)
                        temp.append(shifted_points[1][0])
                        temp.append(shifted_points[1][1])
                        #temp.append(int(comp[2]))
                        temp.append(int(comp[3]))
                        temp.append(comp[4])
                        fin = tuple(temp)
                        final_group.append(fin)
                #prop1.move_xy(0,(prop1.Height/2),prop1.Objetos[0].Material, 0)
                #prop2.move_xy(0,(0-(prop2.Height/2)),prop2.Objetos[0].Material, 0)
            Composites.update({new_value:final_group})
            prop1.get_values()
            prop2.get_values()
            list1 = prop1.Borders
            list2 = prop2.Borders

        #print(list1)
        #print(list2)

    ################################################################################
    #############################< Code Adaptation >################################
    ################################################################################
    sel_operator = Selection(project_root, game_path_tourney, info)
    mut_operator = Mutation(per_mut, mu, sigma, clases)
    mut_operator.UpdateComposites(Composites)
    #####################################################################
    ########################< Class Definitions >########################
    #####################################################################

    
        
        
    class Individual:
        def __init__(self, **kwargs):
            self.chromosome = kwargs.get('chromosome', [])
            self.mask = kwargs.get('mask') #self.assign_mask(Mask_List[kwargs.get('mask')])
            self.__dict__.update(kwargs)
            self.chromosome_objects = [Composite(Composites[composite]) for composite in 
                self.chromosome]
            self.object_list = self.object_list_gen()
            self.object_masked = []
            self.Mut_Movement = [0 for value in self.chromosome]
            self.Mut_Struct = [-1 for value in self.chromosome]
            self.Mut_Material = ["wood" for value in self.chromosome]

        def position_chromosome(self):
            #To do
            # Here you can use the chromosome objects etc.
            pass
        
        def UpdateMutation(self):
            for c, struc in enumerate(self.Mut_Struct):
                if struc != -1:
                    self.chromosome[c] = struc

            self.chromosome_objects = [Composite(Composites[composite]) for composite in 
                self.chromosome]

            for c, objeto in enumerate(self.chromosome_objects):
                for pieza in objeto.Objetos:
                    if self.Mut_Material[c] != 0:
                        pieza.Material = self.Mut_Material[c]
                        pieza.change_material(self.Mut_Material[c])
                        pieza.update_values()
                objeto.as_dictionary = objeto.gen_dictionary()

            for c, mov in enumerate(self.Mut_Movement):
                self.chromosome_objects[c].move_xy(mov, 0, self.Mut_Material[c], 0)

            self.object_list = self.object_list_gen()
            pass
        
        def chromosome_coordinates(self):
            
            return [0, 0]
        
        def object_list_gen(self):
            final_list = []
            for com in self.chromosome_objects:
                com.as_dictionary = com.gen_dictionary()
                obj_list =[]
                obj_list.append(com.as_dictionary)
                final_list.append(obj_list)
            return final_list
        
        def generate_xml(self, **kwargs):
            res_list = []
            res_list = xml.writeXML(self.object_list, os.path.join(project_root, write_path + 
                "/level-0"+ str(kwargs.get('individual')) +".xml"))
            self.ind_height = res_list[0]
            self.ind_piece = res_list[1]
            self.Pieces = res_list[2]
            pass
        
        def read_xml(self, **kwargs):
            self.Remaining_Pieces = xml.readXML(os.path.join(project_root, read_path + 
                "/level-"+ str(kwargs.get('individual')) +".xml"))
            self.ind_piece_count = len(self.Remaining_Pieces)
            pass
        
        def read_xml_tourney(self, **kwargs):
            self.Remaining_Pieces = xml.readXML(os.path.join(project_root, read_path_tourney + 
                "/level-"+ str(kwargs.get('individual')) +".xml"))
            self.ind_piece_count = len(self.Remaining_Pieces)
            pass
        
        def ind_height(self):
            return 0
        
        def ind_piece(self):
            return 0
        
        def ind_piece_count(self):
            return 0

        def assign_mask(self, mask_class):
            masked = mask_class
            print(masked)
            #self.mask = mask_class 
            return masked

        def locate_pigs(self):
            self.Pig_Location = mut_operator.Set_Pigs(self.chromosome_objects, req_pigs, 
                self.mask, self.Composites_Centers)
            pass
        
        def get_fitness(self, chrom_list, pos):
            self.Fitness, self.Fit_Hamming, self.Fit_Pos = 
                Eval.fitness(self.Pieces, 
                self.Remaining_Pieces, self.chromosome, chrom_list, pos)
            return 0
        
        def combine_mask(self):
            self.object_masked, self.Composites_Centers = 
                xml.calculate_mask(self.object_list, 
                self.mask, self.chromosome_objects)
            #self.object_list = xml.calculate_mask(self.object_list, type_castle)
            return 0
        def generate_xml_masked(self, **kwargs):
            res_list = []
            res_list = xml.writeXML_masked(self.Pig_Location, self.object_list, 
                os.path.join(project_root, write_path + "/level-0" + 
                    str(kwargs.get('individual')) + 
                ".xml"))
            self.ind_height = res_list[0]
            self.ind_piece = res_list[1]
            self.Pieces = res_list[2]
            #print("XML Completo")
            pass
        
        def generate_xml_tourney(self, **kwargs):
            res_list = []
            res_list = xml.writeXML_masked(self.Pig_Location, self.object_list, 
                os.path.join(project_root, write_path_tourney + 
                    "/level-0"+ str(kwargs.get('individual')) +".xml"))
            self.ind_height_tourney = res_list[0]
            self.ind_piece_tourney = res_list[1]
            self.Pieces = res_list[2]
            pass

        def generate_xml_elite(self, **kwargs):
            res_list = []
            res_list = xml.writeXML_masked(self.Pig_Location, self.object_list, 
                os.path.join(project_root, elite_path + "/level-" + str(kwargs.get('gen')) + 
                "0" + str(kwargs.get('individual'))  + ".xml"))
            self.ind_height = res_list[0]
            self.ind_piece = res_list[1]
            self.Pieces = res_list[2]
            pass
        

    def create_new_mask(pieces):
        div_list =[]
        while True:
            div_list = [random.randint(0, pieces-1) for col in range(7)]
            if sum(div_list) == pieces:
                break
        
        return div_list

    # Generate a defined number of new composites to add to the pool of selections
    for i in range(0,9):
        combine_pieces()

    pop = [ Individual(chromosome = get_random_chrom(ind_pieces), 
        mask = create_new_mask(ind_pieces)) for i in range(population)]
    
    # variable for controlling that the fitness of the population is compared to 
    # at least 2 others in the same timeline (between resets)
    gen_alive = 0  

    with yaspin(text="Executing algorithm", color="cyan") as sp: 
        while gen < max_gen: #and max(fits) < 100:
                    
            # Outside IF statement
            # Reintegrate the ELITE member to the population and remove the one 
            # in the last possition
            if len(elite):
                for member in elite:
                    pop.insert(0, member)
                    #pop[0] = Individual(chromosome = member[1], mask = member[2])
                    pop = pop[:population]

            # Check if the current number of population multiplied by the 
            # cross-over percentage is an even or odd number, in the later 
            # case remove 1 from the value
            many = len(pop) * per_cross
            if many % 2 == 0:
                pass
            else:
                many = many - 1

            # Combine the mask of the individual before entering the simulation
            ind_c = 0
            for ind in pop:
                if hasattr(ind, 'Fitness'):
                    pass
                else:
                    ind.combine_mask()
                    ind.locate_pigs()
                ind.generate_xml_masked(individual = ind_c)
                ind_c = ind_c + 1
            
            # Runs and instance of the game
            if hasattr(ind, 'Fitness'):
                pass
            else:
                subprocess.call(r'"' + os.path.join(project_root, game_path) + '"', 
                    startupinfo=info)  # doesn't capture output

            # After the simulation obtain the fitness value for the population
            # Read the xml files and get the data
            ind_c = 0
            final_ind_list = []
            for ind in pop:
                value = ind.read_xml(individual = ind_c)
                final_ind_list.append(value)
                ind_c = ind_c + 1

            # Generate a list with the chromosome values of all individuals 
            # (required for Hamming distance)
            chrom_list = []
            for ind in pop:
                chrom_list.append(ind.chromosome)

            # Calculate the fitness for each individual
            for c, ind in enumerate(pop):
                ind.get_fitness(chrom_list, c)
                pass

            ####################################################################
            #############################< Selection steps >####################
            ####################################################################
            
            # Order the population by their fitness
            pop.sort(key=lambda x:x.Fitness, reverse=False)

            # Obtain the "parents" of the generation
            parents = []
            pr = 1
            parents = sel_operator.Selection_Base(pop, many, sel_type)

            ####################################################################
            #############################< Crossover steps >####################
            ####################################################################
            
            new_members = []

            # Generate the cross-over operation (one-point crossover)
            pos_offspring = 0
            for cross_parent in range(0, len(parents), 2):
                # Generate a copy of each parent for the cross-over operation
                father = pop[parents[cross_parent] -1 ].chromosome
                mother = pop[parents[cross_parent + 1] - 1].chromosome
                
                # "Divide" the parents chromosomes for the operation
                father11 = father[0:math.floor(ind_pieces/2)]
                father12 = father[math.floor(ind_pieces/2):]
                
                mother11 = mother[0:math.floor(ind_pieces/2)]
                mother12 = mother[math.floor(ind_pieces/2):]
                
                # Generate the childs of both parents
                son = father11 + mother12
                daughter = mother11 + father12
                
                mask_son = create_new_mask(len(son))
                mask_daughter = create_new_mask(len(daughter))
                # Replace the parents in the generation
                pop[pos_offspring].chromosome = son
                pop[pos_offspring + 1].chromosome = daughter
                
                pop[pos_offspring] = Individual(chromosome = son, mask = mask_son)
                pop[pos_offspring + 1] = 
                    Individual(chromosome = daughter, mask = mask_daughter)

                # Mutate the childs (by chance like throwing a 100 side dice)
                # If greater than the treshold then mutate
                chance = random.randint(1, 100)
                threshold = 100 - (100 * per_mut)
                #chance = 100
                if chance > threshold:
                    var=0
                    new_chrom = 
                        mut_operator.M_Individual(pop[pos_offspring].chromosome)
                    pop[pos_offspring] = Individual(chromosome = new_chrom, 
                        mask = create_new_mask(len(new_chrom)))
                    pop[pos_offspring] = 
                        mut_operator.M_Movement(pop[pos_offspring], 0)
                    pop[pos_offspring] = 
                        mut_operator.M_StrucType(pop[pos_offspring], 0)
                    pop[pos_offspring] = 
                        mut_operator.M_StructMat(pop[pos_offspring], 0)
                    pop[pos_offspring].UpdateMutation()
                    #print("Mutate")
                else:
                    var=1
                    #print("Not Mutate")
                
                # The same for the second child
                chance = random.randint(1, 100)
                threshold = 100 - (100 * per_mut)
                #chance = 100
                if chance > threshold:
                    var=0
                    new_chrom = 
                        mut_operator.M_Individual(pop[pos_offspring + 1].chromosome)
                    pop[pos_offspring + 1] = Individual(chromosome = new_chrom, 
                        mask = create_new_mask(len(new_chrom)))
                    pop[pos_offspring + 1] = 
                        mut_operator.M_Movement(pop[pos_offspring + 1], 0)
                    pop[pos_offspring + 1] = 
                        mut_operator.M_StrucType(pop[pos_offspring + 1], 0)
                    pop[pos_offspring + 1] = 
                        mut_operator.M_StructMat(pop[pos_offspring + 1], 0)
                    pop[pos_offspring + 1].UpdateMutation()
                    #print("Mutate")
                
                pop[pos_offspring].ind_c = pos_offspring
                pop[pos_offspring + 1].ind_c = pos_offspring + 1
                new_members.append(pop[pos_offspring])
                new_members.append(pop[pos_offspring + 1])
            
            # Calculate the new individuals fitness by sending them to a 
            # diferent simulation track
            
            # Generate an XML to check the fitness
            for ind_c, ind in enumerate(new_members):
                ind.combine_mask()
                ind.locate_pigs()
                ind.generate_xml_tourney(individual = ind_c)
            
            # Execute the application with the two memebers
            subprocess.call(r'"' + os.path.join(project_root, game_path_tourney) + '"', 
                startupinfo=info)

            # Generate a list with the chromosome values of all individuals 
            # (required for Hamming distance)
            chrom_list = []
            for ind in pop:
                chrom_list.append(ind.chromosome)

            # Then obtain the remaining fitness values
            for c, ind in enumerate(new_members):
                ind.read_xml_tourney(individual = ind.ind_c)
                ind.get_fitness(chrom_list, c)

            ####################################################################
            #############################< ELITE selection >####################
            ####################################################################

            # Obtain the average fitness of the generation
            gen_fit = 0
            hamming_fit = 0
            mov_fit = 0
            best_ind = 0
            fit_pop = []
            for c, ind in enumerate(pop):
                fit_pop.append([c, ind.Fitness])
                gen_fit = gen_fit + ind.Fitness
                hamming_fit += ind.Fit_Hamming
                mov_fit += ind.Fit_Pos
            
            fit_pop.sort(key=lambda x:x[1], reverse=True)
            max_fit.append(fit_pop[0][1])
            min_fit.append(fit_pop[-1][1])
            fit_pop = fit_pop[:5]
            
            # 
            best_gen.append(fit_pop[0][1])

            # Add the best value to the elite list
            for e in fit_pop:
                elite.append(pop[e[0]])
                elite[0].generate_xml_elite(individual = e[0], gen = gen)

            elite.sort(key=lambda x:x.Fitness, reverse=True)
            elite = elite[:max_elite]

            all_fit.append((gen_fit/len(pop)))
            fit_ham.append((hamming_fit/len(pop)))
            fit_Amov.append((mov_fit/len(pop)))
            
            # Increase value of the generation for the next cycle
            gen = gen + 1
            gen_alive += 1

            # Print the time of the generation
            t_gen = datetime.datetime.now()
            sp.write("> Gen " + str(gen) + " complete, gen duration: " + 
                str(t_gen-t_prev) + ", current time: " + str(t_gen-t_begin))
            t_prev = datetime.datetime.now()

            # Copy the resulting files to a folder with the number of generation
            destination = os.path.join(project_root, level_files_path + "/generation-" + 
                str(current_gen_folder))
            shutil.copytree(sourcefolder, destination)
            current_gen_folder += 1

        t_finish = datetime.datetime.now()
        #print("Total time is: " + str(t_finish-t_begin))
        sp.write("> Total time is: " + str(t_finish-t_begin))

        # Stop the spinner
        sp.ok("Ok")
        
    # Plot the results for Fitness
    pylab.figure(figsize=(8, 5))
    plot(all_fit, '-.b', label='General Fitness')
    plot(min_fit, '-g', label='Min fitness value')
    plot(max_fit, '*-r', label='Max fitness value')
    lgd = pylab.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    pylab.savefig('Fitness', bbox_extra_artists=(lgd,), bbox_inches='tight')

    # Same for Hamming Distance
    pylab.figure(figsize=(8, 5))
    plot(fit_ham, '-g', label='Average Hamming Distance')
    lgd = pylab.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    pylab.savefig('Hamming', bbox_extra_artists=(lgd,), bbox_inches='tight')

    # Add the data to the json files
    json_data['all_fit'] = all_fit
    json_data['hamming_avg'] = fit_ham
    json_data['min_fit'] = min_fit
    json_data['max_fit'] = max_fit

    with open('results.json','w') as outfile:
        print(outfile)
        json.dump(json_data, outfile)

    # Clean the workspace
    shutil.copytree(experimentsource, experimentdestination)

    shutil.copyfile('results.json',
        os.path.join(project_root, experimentdest) + '/results.json')
    shutil.copyfile('Fitness.png',
        os.path.join(project_root, experimentdest) + '/Fitness.png')
    shutil.copyfile('Hamming.png',
        os.path.join(project_root, experimentdest) + '/Hamming.png')
    \end{minted}

\subsection{Código para calculo de fitness}
\label{appa:code_fitness}
\begin{minted}[frame=lines, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, linenos]{python}
    # Evaluation metrics for the fitness of the individuals
    #
    # The metric to evaluate the fitness of an individual are:
    # 1. If the number of pieces is different give a penalty
    # 2. If the positioning of the pieces is diferent for more than 1 give a penalty
    # The penalties are given has follows
    # Initial fitness 100%
    # - size_difference 
    #       (remaining_pieces * 100) / original_pieces
    # - position_error
    #       for each piece
    #           if the piece position is different by more than 2
    #               ((1 * 100) / original_pieces)
    #           else
    #               ((1 * 100) / original_pieces) * (((abs(position) * 100) / 2) / 100)
    # 
    #            Check the angle
    #               if different by more/less than ± 5 then penalize
    #####################################################################################
    #
    # After the evaluation is over if a stable group remains in the file
    # this group will be added to the pool of pieces
    # 
    #

    from AngryBirdsGA import *
    import math
    import hashlib
    from copy import deepcopy


    def fitness(ind_orig, ind_fin, chromosome, pop, pos):
        criteria = 0
        #criteria = size_dif(ind_orig, ind_fin)
        criteria += (dif_pieces(chromosome) * 10) # 240
        criteria += calc_entropy(chromosome) * 100
        hamming_dist = deepcopy(calc_hamming(chromosome, pop, pos))
        criteria += hamming_dist
        
        criteria_new = [deepcopy(criteria), deepcopy(hamming_dist)]
        
        #Evaluate fitness based on stability
        tot_fitness = 0
        tot_fitness += deepcopy(size_dif(ind_orig, ind_fin))
        tot_fitness += deepcopy(position_error(ind_orig, ind_fin))
        
        return [tot_fitness, criteria_new, 100]

    def calc_hamming(chromosome, pop, pos):
        total = []
        for c, chrom in enumerate(pop):
            if c != pos:
                total.append(deepcopy(hamming_distance(deepcopy(chromosome), 
                    deepcopy(chrom))))

        total.sort(key=lambda x:x, reverse=True)
        return total[0]


    def calc_entropy(ind):
        # First calculate the frequency of the elements in array
        value_list = set(ind)

        freqList = []
        for piece in value_list:
            ctr = 0
            for ch in ind:
                if ch == piece:
                    ctr += 1
            freqList.append(float(ctr) / len(ind))
        
        result = 0
        for e in freqList:
            result += (e*math.log(e,2))
        result = -result
        return result

    def dif_pieces(b):
        #type_list = [piece[0] for piece in b]
        return len(set(b))

    def size_dif(a, b):
        val_a = len(a)                      # Original amount
        val_b = len(b)                      # Remaining amount 
        percentage = (val_b * 100)/val_a    # Percentage to remove from total
        return percentage

    def position_error(a, b):
        total_error = 0
        for piece in b: 
            # 0 = Block     
            # 1 = Material    
            # 2 = x   
            # 3 = y   
            # 4 = r   
            # 5 = id
            try:
                orig = a[int(piece[5])]
                error_xy = 0 if 1.0 > math.hypot((float(piece[2])) - (float(orig[2])), 
                    (float(piece[3])) - (float(orig[3]))) else ((100/len(a)) * -0.5)
                error_z = 0 if -5 < (abs(float(orig[4])) - abs(float(piece[4]))) < 5 else 
                    ((100/len(a)) * -0.5)
                total_error = total_error + error_xy + error_z
            except IndexError:
                text = "Missing values - Pieces destroyed or something?..."
        return total_error


    def hamming_distance(a, b):
        # Calculate and return the Hamming distance of the two sets 
        return sum(c1 != c2 for c1, c2 in zip(a, b))
\end{minted}